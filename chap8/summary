如果两个变量指代的不可变对象具有相同的值（a == b 为 True），
实际上它们指代的是副本还是同一个对象的别名基本没什么关系，
因为不可变对象的值不会变，但有一个例外。
这里说的例外是不可变的集合，如元组和 frozenset：
如果不可变集合保存的是可变元素的引用，那么可变元素的值发生变化后，不可变集合也会随之改变。
实际上，这种情况不是很常见。不可变集合不变的是所含对象的标识。

变量保存的是引用，这一点对 Python 编程有很多实际的影响。

    1. 简单的赋值不创建副本。

    2. 对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。

    3. 为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。
    如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。

    4. 函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。
    这一行为无法避免，除非在本地创建副本，或者使用不可变对象（例如，传入元组，而不传入列表）。

    5. 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变了，这会影响以后使用默认值的调用。

在 CPython 中，对象的引用数量归零后，对象会被立即销毁。
如果除了循环引用之外没有其他引用，两个对象都会被销毁。
某些情况下，可能需要保存对象的引用，但不留存对象本身。
例如，有一个类想要记录所有实例。
这个需求可以使用弱引用实现，这是一种低层机制，是 weakref 模块中 WeakValueDictionary、WeakKeyDictionary
和 WeakSet 等有用的集合类，以及 finalize 函数的底层支持。